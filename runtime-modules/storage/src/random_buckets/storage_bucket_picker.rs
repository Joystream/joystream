#![warn(missing_docs)]

use sp_std::cell::RefCell;
use sp_std::collections::btree_set::BTreeSet;
use sp_std::marker::PhantomData;

pub(crate) use super::{RandomBucketIdIterator, SequentialBucketIdIterator};
use crate::{DynamicBagType, Module, Trait, VoucherUpdate};

// Generates storage bucket IDs to assign to a new dynamic bag.
pub(crate) struct StorageBucketPicker<T> {
    trait_marker: PhantomData<T>,
}

impl<T: Trait> StorageBucketPicker<T> {
    // Selects storage bucket ID sets to assign to the dynamic bag.
    // At first, it tries to generate random bucket IDs. If acquired random IDs number is not enough
    // it tries to get additional IDs starting from zero up to the total number of the possible IDs.
    // The function filters deleted buckets and disabled buckets (accepting_new_bags == false)
    // Total number of possible IDs is limited by the dynamic bag settings.
    // Returns an accumulated bucket ID set or an empty set.
    pub(crate) fn pick_storage_buckets(
        bag_type: DynamicBagType,
        voucher_update: Option<VoucherUpdate>,
    ) -> BTreeSet<T::StorageBucketId> {
        let creation_policy = Module::<T>::get_dynamic_bag_creation_policy(bag_type);

        if creation_policy.no_storage_buckets_required() {
            return BTreeSet::new();
        }

        let required_bucket_num = creation_policy.number_of_storage_buckets as usize;

        // TODO: the selection algorithm will change: https://github.com/Joystream/joystream/issues/2904
        // Storage bucket IDs accumulator.
        let bucket_ids_cell = RefCell::new(BTreeSet::new());
        let next_storage_bucket_id = Module::<T>::next_storage_bucket_id();
        RandomBucketIdIterator::<T, T::StorageBucketId>::new(next_storage_bucket_id)
            .chain(SequentialBucketIdIterator::<T, T::StorageBucketId>::new(
                next_storage_bucket_id,
            ))
            .filter(|id| Self::check_storage_bucket_is_valid_for_bag_assigning(id, &voucher_update))
            .filter(|bucket_id| {
                let bucket_ids = bucket_ids_cell.borrow();

                // Skips the iteration on existing ID.
                !bucket_ids.contains(bucket_id)
            })
            .take(required_bucket_num)
            .for_each(|bucket_id| {
                let mut bucket_ids = bucket_ids_cell.borrow_mut();

                bucket_ids.insert(bucket_id);
            });

        bucket_ids_cell.into_inner()
    }

    // Verifies storage bucket ID (non-deleted and accepting new bags).
    pub(crate) fn check_storage_bucket_is_valid_for_bag_assigning(
        bucket_id: &T::StorageBucketId,
        voucher_update: &Option<VoucherUpdate>,
    ) -> bool {
        // Check bucket for existence (return false if not). Check `accepting_new_bags`.
        let bucket = Module::<T>::ensure_storage_bucket_exists(bucket_id).ok();

        // check that bucket is accepting new bags
        let accepting_bags = bucket
            .as_ref()
            .map_or(false, |bucket| bucket.accepting_new_bags);

        // check that buckets has enough room for objects and size
        let limits_sufficient = bucket.as_ref().map_or(false, |bucket| {
            voucher_update.map_or(true, |voucher_update| {
                let num_objects_enough = bucket.voucher.objects_limit
                    >= bucket
                        .voucher
                        .objects_used
                        .saturating_add(voucher_update.objects_number);
                let size_enough = bucket.voucher.size_limit
                    >= bucket
                        .voucher
                        .size_used
                        .saturating_add(voucher_update.objects_total_size);
                size_enough && num_objects_enough
            })
        });
        accepting_bags && limits_sufficient
    }
}
