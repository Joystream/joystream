enum AssetAvailability {
  ACCEPTED
  PENDING
  INVALID
}

interface BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

type BaseModel implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

type BaseModelUUID implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

input BaseWhereInput {
  id_eq: String
  id_in: [String!]
  createdAt_eq: String
  createdAt_lt: String
  createdAt_lte: String
  createdAt_gt: String
  createdAt_gte: String
  createdById_eq: String
  updatedAt_eq: String
  updatedAt_lt: String
  updatedAt_lte: String
  updatedAt_gt: String
  updatedAt_gte: String
  updatedById_eq: String
  deletedAt_all: Boolean
  deletedAt_eq: String
  deletedAt_lt: String
  deletedAt_lte: String
  deletedAt_gt: String
  deletedAt_gte: String
  deletedById_eq: String
}

type CuratorGroup implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """Curators belonging to this group"""
  curatorIds: [Int!]!

  """Is group active or not"""
  isActive: Boolean!
  channels: [Channel!]!
}

type CuratorGroupConnection {
  totalCount: Int!
  edges: [CuratorGroupEdge!]!
  pageInfo: PageInfo!
}

input CuratorGroupCreateInput {
  curatorIds: [Int!]!
  isActive: Boolean!
}

type CuratorGroupEdge {
  node: CuratorGroup!
  cursor: String!
}

enum CuratorGroupOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  isActive_ASC
  isActive_DESC
}

input CuratorGroupUpdateInput {
  curatorIds: [Int!]
  isActive: Boolean
}

input CuratorGroupWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  isActive_eq: Boolean
  isActive_in: [Boolean!]
}

input CuratorGroupWhereUniqueInput {
  id: ID!
}

"""Manages content ids, type and storage provider decision about it"""
type DataObject implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """Content owner"""
  owner: DataObjectOwner!

  """Content added at"""
  createdInBlock: Int!

  """Content type id"""
  typeId: Int!

  """Content size in bytes"""
  size: Float!
  liaison: Worker
  liaisonId: String

  """Storage provider as liaison judgment"""
  liaisonJudgement: LiaisonJudgement!

  """IPFS content id"""
  ipfsContentId: String!

  """Joystream runtime content"""
  joystreamContentId: String!
  channelcoverPhotoDataObject: [Channel!]
  channelavatarPhotoDataObject: [Channel!]
  videothumbnailPhotoDataObject: [Video!]
  videomediaDataObject: [Video!]
}

type DataObjectConnection {
  totalCount: Int!
  edges: [DataObjectEdge!]!
  pageInfo: PageInfo!
}

input DataObjectCreateInput {
  owner: JSONObject!
  createdInBlock: Float!
  typeId: Float!
  size: Float!
  liaisonId: ID
  liaisonJudgement: LiaisonJudgement!
  ipfsContentId: String!
  joystreamContentId: String!
}

type DataObjectEdge {
  node: DataObject!
  cursor: String!
}

enum DataObjectOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  createdInBlock_ASC
  createdInBlock_DESC
  typeId_ASC
  typeId_DESC
  size_ASC
  size_DESC
  liaisonId_ASC
  liaisonId_DESC
  liaisonJudgement_ASC
  liaisonJudgement_DESC
  ipfsContentId_ASC
  ipfsContentId_DESC
  joystreamContentId_ASC
  joystreamContentId_DESC
}

union DataObjectOwner = DataObjectOwnerMember | DataObjectOwnerChannel | DataObjectOwnerDao | DataObjectOwnerCouncil | DataObjectOwnerWorkingGroup

type DataObjectOwnerCouncil {
  """Variant needs to have at least one property. This value is not used."""
  dummy: Int
}

input DataObjectOwnerCouncilCreateInput {
  dummy: Float
}

input DataObjectOwnerCouncilUpdateInput {
  dummy: Float
}

input DataObjectOwnerCouncilWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  dummy_eq: Int
  dummy_gt: Int
  dummy_gte: Int
  dummy_lt: Int
  dummy_lte: Int
  dummy_in: [Int!]
}

input DataObjectOwnerCouncilWhereUniqueInput {
  id: ID!
}

type DataObjectOwnerDao {
  """DAO identifier"""
  dao: Int!
}

input DataObjectOwnerDaoCreateInput {
  dao: Float!
}

input DataObjectOwnerDaoUpdateInput {
  dao: Float
}

input DataObjectOwnerDaoWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  dao_eq: Int
  dao_gt: Int
  dao_gte: Int
  dao_lt: Int
  dao_lte: Int
  dao_in: [Int!]
}

input DataObjectOwnerDaoWhereUniqueInput {
  id: ID!
}

type DataObjectOwnerChannel {
  """Channel identifier"""
  channel: Int!

  """Variant needs to have at least one property. This value is not used."""
  dummy: Int
}

input DataObjectOwnerChannelCreateInput {
  channel: Float!
  dummy: Float
}

input DataObjectOwnerChannelUpdateInput {
  channel: Float
  dummy: Float
}

input DataObjectOwnerChannelWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  channel_eq: Int
  channel_gt: Int
  channel_gte: Int
  channel_lt: Int
  channel_lte: Int
  channel_in: [Int!]
  dummy_eq: Int
  dummy_gt: Int
  dummy_gte: Int
  dummy_lt: Int
  dummy_lte: Int
  dummy_in: [Int!]
}

input DataObjectOwnerChannelWhereUniqueInput {
  id: ID!
}

type DataObjectOwnerMember {
  """Member identifier"""
  member: Int!

  """Variant needs to have at least one property. This value is not used."""
  dummy: Int
}

input DataObjectOwnerMemberCreateInput {
  member: Float!
  dummy: Float
}

input DataObjectOwnerMemberUpdateInput {
  member: Float
  dummy: Float
}

input DataObjectOwnerMemberWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  member_eq: Int
  member_gt: Int
  member_gte: Int
  member_lt: Int
  member_lte: Int
  member_in: [Int!]
  dummy_eq: Int
  dummy_gt: Int
  dummy_gte: Int
  dummy_lt: Int
  dummy_lte: Int
  dummy_in: [Int!]
}

input DataObjectOwnerMemberWhereUniqueInput {
  id: ID!
}

type DataObjectOwnerWorkingGroup {
  """Working group identifier"""
  workingGroup: Int!
}

input DataObjectOwnerWorkingGroupCreateInput {
  workingGroup: Float!
}

input DataObjectOwnerWorkingGroupUpdateInput {
  workingGroup: Float
}

input DataObjectOwnerWorkingGroupWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  workingGroup_eq: Int
  workingGroup_gt: Int
  workingGroup_gte: Int
  workingGroup_lt: Int
  workingGroup_lte: Int
  workingGroup_in: [Int!]
}

input DataObjectOwnerWorkingGroupWhereUniqueInput {
  id: ID!
}

input DataObjectUpdateInput {
  owner: JSONObject
  createdInBlock: Float
  typeId: Float
  size: Float
  liaisonId: ID
  liaisonJudgement: LiaisonJudgement
  ipfsContentId: String
  joystreamContentId: String
}

input DataObjectWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  owner_json: JSONObject
  createdInBlock_eq: Int
  createdInBlock_gt: Int
  createdInBlock_gte: Int
  createdInBlock_lt: Int
  createdInBlock_lte: Int
  createdInBlock_in: [Int!]
  typeId_eq: Int
  typeId_gt: Int
  typeId_gte: Int
  typeId_lt: Int
  typeId_lte: Int
  typeId_in: [Int!]
  size_eq: Float
  size_gt: Float
  size_gte: Float
  size_lt: Float
  size_lte: Float
  size_in: [Float!]
  liaisonId_eq: ID
  liaisonId_in: [ID!]
  liaisonJudgement_eq: LiaisonJudgement
  liaisonJudgement_in: [LiaisonJudgement!]
  ipfsContentId_eq: String
  ipfsContentId_contains: String
  ipfsContentId_startsWith: String
  ipfsContentId_endsWith: String
  ipfsContentId_in: [String!]
  joystreamContentId_eq: String
  joystreamContentId_contains: String
  joystreamContentId_startsWith: String
  joystreamContentId_endsWith: String
  joystreamContentId_in: [String!]
}

input DataObjectWhereUniqueInput {
  id: ID!
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

interface DeleteResponse {
  id: ID!
}

type Channel implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  ownerMember: Membership
  ownerMemberId: String
  ownerCuratorGroup: CuratorGroup
  ownerCuratorGroupId: String
  category: ChannelCategory
  categoryId: String

  """Reward account where revenue is sent if set."""
  rewardAccount: String

  """The title of the Channel"""
  title: String

  """The description of a Channel"""
  description: String
  coverPhotoDataObject: DataObject
  coverPhotoDataObjectId: String

  """URLs where the asset content can be accessed (if any)"""
  coverPhotoUrls: [String!]!

  """Availability meta information"""
  coverPhotoAvailability: AssetAvailability!
  avatarPhotoDataObject: DataObject
  avatarPhotoDataObjectId: String

  """URLs where the asset content can be accessed (if any)"""
  avatarPhotoUrls: [String!]!

  """Availability meta information"""
  avatarPhotoAvailability: AssetAvailability!

  """Flag signaling whether a channel is public."""
  isPublic: Boolean

  """Flag signaling whether a channel is censored."""
  isCensored: Boolean!
  language: Language
  languageId: String
  videos: [Video!]!
  createdInBlock: Int!
}

type ChannelCategoriesByNameFTSOutput {
  item: ChannelCategoriesByNameSearchResult!
  rank: Float!
  isTypeOf: String!
  highlight: String!
}

union ChannelCategoriesByNameSearchResult = ChannelCategory

"""Category of media channel"""
type ChannelCategory implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """The name of the category"""
  name: String
  channels: [Channel!]!
  createdInBlock: Int!
}

type ChannelCategoryConnection {
  totalCount: Int!
  edges: [ChannelCategoryEdge!]!
  pageInfo: PageInfo!
}

input ChannelCategoryCreateInput {
  name: String
  createdInBlock: Float!
}

type ChannelCategoryEdge {
  node: ChannelCategory!
  cursor: String!
}

enum ChannelCategoryOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  name_ASC
  name_DESC
  createdInBlock_ASC
  createdInBlock_DESC
}

input ChannelCategoryUpdateInput {
  name: String
  createdInBlock: Float
}

input ChannelCategoryWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  name_eq: String
  name_contains: String
  name_startsWith: String
  name_endsWith: String
  name_in: [String!]
  createdInBlock_eq: Int
  createdInBlock_gt: Int
  createdInBlock_gte: Int
  createdInBlock_lt: Int
  createdInBlock_lte: Int
  createdInBlock_in: [Int!]
}

input ChannelCategoryWhereUniqueInput {
  id: ID!
}

type ChannelConnection {
  totalCount: Int!
  edges: [ChannelEdge!]!
  pageInfo: PageInfo!
}

input ChannelCreateInput {
  ownerMemberId: ID
  ownerCuratorGroupId: ID
  categoryId: ID
  rewardAccount: String
  title: String
  description: String
  coverPhotoDataObjectId: ID
  coverPhotoUrls: [String!]!
  coverPhotoAvailability: AssetAvailability!
  avatarPhotoDataObjectId: ID
  avatarPhotoUrls: [String!]!
  avatarPhotoAvailability: AssetAvailability!
  isPublic: Boolean
  isCensored: Boolean!
  languageId: ID
  createdInBlock: Float!
}

type ChannelEdge {
  node: Channel!
  cursor: String!
}

enum ChannelOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  ownerMemberId_ASC
  ownerMemberId_DESC
  ownerCuratorGroupId_ASC
  ownerCuratorGroupId_DESC
  categoryId_ASC
  categoryId_DESC
  rewardAccount_ASC
  rewardAccount_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  coverPhotoDataObjectId_ASC
  coverPhotoDataObjectId_DESC
  coverPhotoAvailability_ASC
  coverPhotoAvailability_DESC
  avatarPhotoDataObjectId_ASC
  avatarPhotoDataObjectId_DESC
  avatarPhotoAvailability_ASC
  avatarPhotoAvailability_DESC
  isPublic_ASC
  isPublic_DESC
  isCensored_ASC
  isCensored_DESC
  languageId_ASC
  languageId_DESC
  createdInBlock_ASC
  createdInBlock_DESC
}

input ChannelUpdateInput {
  ownerMemberId: ID
  ownerCuratorGroupId: ID
  categoryId: ID
  rewardAccount: String
  title: String
  description: String
  coverPhotoDataObjectId: ID
  coverPhotoUrls: [String!]
  coverPhotoAvailability: AssetAvailability
  avatarPhotoDataObjectId: ID
  avatarPhotoUrls: [String!]
  avatarPhotoAvailability: AssetAvailability
  isPublic: Boolean
  isCensored: Boolean
  languageId: ID
  createdInBlock: Float
}

input ChannelWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  ownerMemberId_eq: ID
  ownerMemberId_in: [ID!]
  ownerCuratorGroupId_eq: ID
  ownerCuratorGroupId_in: [ID!]
  categoryId_eq: ID
  categoryId_in: [ID!]
  rewardAccount_eq: String
  rewardAccount_contains: String
  rewardAccount_startsWith: String
  rewardAccount_endsWith: String
  rewardAccount_in: [String!]
  title_eq: String
  title_contains: String
  title_startsWith: String
  title_endsWith: String
  title_in: [String!]
  description_eq: String
  description_contains: String
  description_startsWith: String
  description_endsWith: String
  description_in: [String!]
  coverPhotoDataObjectId_eq: ID
  coverPhotoDataObjectId_in: [ID!]
  coverPhotoAvailability_eq: AssetAvailability
  coverPhotoAvailability_in: [AssetAvailability!]
  avatarPhotoDataObjectId_eq: ID
  avatarPhotoDataObjectId_in: [ID!]
  avatarPhotoAvailability_eq: AssetAvailability
  avatarPhotoAvailability_in: [AssetAvailability!]
  isPublic_eq: Boolean
  isPublic_in: [Boolean!]
  isCensored_eq: Boolean
  isCensored_in: [Boolean!]
  languageId_eq: ID
  languageId_in: [ID!]
  createdInBlock_eq: Int
  createdInBlock_gt: Int
  createdInBlock_gte: Int
  createdInBlock_lt: Int
  createdInBlock_lte: Int
  createdInBlock_in: [Int!]
}

input ChannelWhereUniqueInput {
  id: ID!
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type Language implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """Language identifier ISO 639-1"""
  iso: String!
  createdInBlock: Int!
  channellanguage: [Channel!]
  videolanguage: [Video!]
}

type LanguageConnection {
  totalCount: Int!
  edges: [LanguageEdge!]!
  pageInfo: PageInfo!
}

input LanguageCreateInput {
  iso: String!
  createdInBlock: Float!
}

type LanguageEdge {
  node: Language!
  cursor: String!
}

enum LanguageOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  iso_ASC
  iso_DESC
  createdInBlock_ASC
  createdInBlock_DESC
}

input LanguageUpdateInput {
  iso: String
  createdInBlock: Float
}

input LanguageWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  iso_eq: String
  iso_contains: String
  iso_startsWith: String
  iso_endsWith: String
  iso_in: [String!]
  createdInBlock_eq: Int
  createdInBlock_gt: Int
  createdInBlock_gte: Int
  createdInBlock_lt: Int
  createdInBlock_lte: Int
  createdInBlock_in: [Int!]
}

input LanguageWhereUniqueInput {
  id: ID!
}

enum LiaisonJudgement {
  PENDING
  ACCEPTED
}

type License implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """License code defined by Joystream"""
  code: Int

  """Attribution (if required by the license)"""
  attribution: String

  """Custom license content"""
  customText: String
  videolicense: [Video!]
}

type LicenseConnection {
  totalCount: Int!
  edges: [LicenseEdge!]!
  pageInfo: PageInfo!
}

input LicenseCreateInput {
  code: Float
  attribution: String
  customText: String
}

type LicenseEdge {
  node: License!
  cursor: String!
}

enum LicenseOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  code_ASC
  code_DESC
  attribution_ASC
  attribution_DESC
  customText_ASC
  customText_DESC
}

input LicenseUpdateInput {
  code: Float
  attribution: String
  customText: String
}

input LicenseWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  code_eq: Int
  code_gt: Int
  code_gte: Int
  code_lt: Int
  code_lte: Int
  code_in: [Int!]
  attribution_eq: String
  attribution_contains: String
  attribution_startsWith: String
  attribution_endsWith: String
  attribution_in: [String!]
  customText_eq: String
  customText_contains: String
  customText_startsWith: String
  customText_endsWith: String
  customText_in: [String!]
}

input LicenseWhereUniqueInput {
  id: ID!
}

type MembersByHandleFTSOutput {
  item: MembersByHandleSearchResult!
  rank: Float!
  isTypeOf: String!
  highlight: String!
}

union MembersByHandleSearchResult = Membership

"""Stored information about a registered user"""
type Membership implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """The unique handle chosen by member"""
  handle: String!

  """A Url to member's Avatar image"""
  avatarUri: String

  """Short text chosen by member to share information about themselves"""
  about: String

  """Member's controller account id"""
  controllerAccount: String!

  """Member's root account id"""
  rootAccount: String!

  """Blocknumber when member was registered"""
  createdInBlock: Int!

  """How the member was registered"""
  entry: MembershipEntryMethod!

  """The type of subscription the member has purchased if any."""
  subscription: Int
  channels: [Channel!]!
}

type MembershipConnection {
  totalCount: Int!
  edges: [MembershipEdge!]!
  pageInfo: PageInfo!
}

input MembershipCreateInput {
  handle: String!
  avatarUri: String
  about: String
  controllerAccount: String!
  rootAccount: String!
  createdInBlock: Float!
  entry: MembershipEntryMethod!
  subscription: Float
}

type MembershipEdge {
  node: Membership!
  cursor: String!
}

enum MembershipEntryMethod {
  PAID
  SCREENING
  GENESIS
}

enum MembershipOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  handle_ASC
  handle_DESC
  avatarUri_ASC
  avatarUri_DESC
  about_ASC
  about_DESC
  controllerAccount_ASC
  controllerAccount_DESC
  rootAccount_ASC
  rootAccount_DESC
  createdInBlock_ASC
  createdInBlock_DESC
  entry_ASC
  entry_DESC
  subscription_ASC
  subscription_DESC
}

input MembershipUpdateInput {
  handle: String
  avatarUri: String
  about: String
  controllerAccount: String
  rootAccount: String
  createdInBlock: Float
  entry: MembershipEntryMethod
  subscription: Float
}

input MembershipWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  handle_eq: String
  handle_contains: String
  handle_startsWith: String
  handle_endsWith: String
  handle_in: [String!]
  avatarUri_eq: String
  avatarUri_contains: String
  avatarUri_startsWith: String
  avatarUri_endsWith: String
  avatarUri_in: [String!]
  about_eq: String
  about_contains: String
  about_startsWith: String
  about_endsWith: String
  about_in: [String!]
  controllerAccount_eq: String
  controllerAccount_contains: String
  controllerAccount_startsWith: String
  controllerAccount_endsWith: String
  controllerAccount_in: [String!]
  rootAccount_eq: String
  rootAccount_contains: String
  rootAccount_startsWith: String
  rootAccount_endsWith: String
  rootAccount_in: [String!]
  createdInBlock_eq: Int
  createdInBlock_gt: Int
  createdInBlock_gte: Int
  createdInBlock_lt: Int
  createdInBlock_lte: Int
  createdInBlock_in: [Int!]
  entry_eq: MembershipEntryMethod
  entry_in: [MembershipEntryMethod!]
  subscription_eq: Int
  subscription_gt: Int
  subscription_gte: Int
  subscription_lt: Int
  subscription_lte: Int
  subscription_in: [Int!]
}

input MembershipWhereUniqueInput {
  id: ID
  handle: String
}

type NextEntityId implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """Next deterministic id for entities without custom id"""
  nextId: Float!
}

type NextEntityIdConnection {
  totalCount: Int!
  edges: [NextEntityIdEdge!]!
  pageInfo: PageInfo!
}

input NextEntityIdCreateInput {
  nextId: Float!
}

type NextEntityIdEdge {
  node: NextEntityId!
  cursor: String!
}

enum NextEntityIdOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  nextId_ASC
  nextId_DESC
}

input NextEntityIdUpdateInput {
  nextId: Float
}

input NextEntityIdWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  nextId_eq: Float
  nextId_gt: Float
  nextId_gte: Float
  nextId_lt: Float
  nextId_lte: Float
  nextId_in: [Float!]
}

input NextEntityIdWhereUniqueInput {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type ProcessorState {
  lastCompleteBlock: Float!
  lastProcessedEvent: String!
  indexerHead: Float!
  chainHead: Float!
}

type Query {
  curatorGroups(offset: Int, limit: Int = 50, where: CuratorGroupWhereInput, orderBy: CuratorGroupOrderByInput): [CuratorGroup!]!
  curatorGroupByUniqueInput(where: CuratorGroupWhereUniqueInput!): CuratorGroup
  curatorGroupsConnection(first: Int, after: String, last: Int, before: String, where: CuratorGroupWhereInput, orderBy: CuratorGroupOrderByInput): CuratorGroupConnection!
  dataObjects(offset: Int, limit: Int = 50, where: DataObjectWhereInput, orderBy: DataObjectOrderByInput): [DataObject!]!
  dataObjectByUniqueInput(where: DataObjectWhereUniqueInput!): DataObject
  dataObjectsConnection(first: Int, after: String, last: Int, before: String, where: DataObjectWhereInput, orderBy: DataObjectOrderByInput): DataObjectConnection!
  channelCategories(offset: Int, limit: Int = 50, where: ChannelCategoryWhereInput, orderBy: ChannelCategoryOrderByInput): [ChannelCategory!]!
  channelCategoryByUniqueInput(where: ChannelCategoryWhereUniqueInput!): ChannelCategory
  channelCategoriesConnection(first: Int, after: String, last: Int, before: String, where: ChannelCategoryWhereInput, orderBy: ChannelCategoryOrderByInput): ChannelCategoryConnection!
  channels(offset: Int, limit: Int = 50, where: ChannelWhereInput, orderBy: ChannelOrderByInput): [Channel!]!
  channelByUniqueInput(where: ChannelWhereUniqueInput!): Channel
  channelsConnection(first: Int, after: String, last: Int, before: String, where: ChannelWhereInput, orderBy: ChannelOrderByInput): ChannelConnection!
  languages(offset: Int, limit: Int = 50, where: LanguageWhereInput, orderBy: LanguageOrderByInput): [Language!]!
  languageByUniqueInput(where: LanguageWhereUniqueInput!): Language
  languagesConnection(first: Int, after: String, last: Int, before: String, where: LanguageWhereInput, orderBy: LanguageOrderByInput): LanguageConnection!
  licenses(offset: Int, limit: Int = 50, where: LicenseWhereInput, orderBy: LicenseOrderByInput): [License!]!
  licenseByUniqueInput(where: LicenseWhereUniqueInput!): License
  licensesConnection(first: Int, after: String, last: Int, before: String, where: LicenseWhereInput, orderBy: LicenseOrderByInput): LicenseConnection!
  memberships(offset: Int, limit: Int = 50, where: MembershipWhereInput, orderBy: MembershipOrderByInput): [Membership!]!
  membershipByUniqueInput(where: MembershipWhereUniqueInput!): Membership
  membershipsConnection(first: Int, after: String, last: Int, before: String, where: MembershipWhereInput, orderBy: MembershipOrderByInput): MembershipConnection!
  nextEntityIds(offset: Int, limit: Int = 50, where: NextEntityIdWhereInput, orderBy: NextEntityIdOrderByInput): [NextEntityId!]!
  nextEntityIdByUniqueInput(where: NextEntityIdWhereUniqueInput!): NextEntityId
  nextEntityIdsConnection(first: Int, after: String, last: Int, before: String, where: NextEntityIdWhereInput, orderBy: NextEntityIdOrderByInput): NextEntityIdConnection!
  channelCategoriesByName(whereChannelCategory: ChannelCategoryWhereInput, skip: Int = 0, limit: Int = 5, text: String!): [ChannelCategoriesByNameFTSOutput!]!
  membersByHandle(whereMembership: MembershipWhereInput, skip: Int = 0, limit: Int = 5, text: String!): [MembersByHandleFTSOutput!]!
  search(whereVideo: VideoWhereInput, whereChannel: ChannelWhereInput, skip: Int = 0, limit: Int = 5, text: String!): [SearchFTSOutput!]!
  videoCategoriesByName(whereVideoCategory: VideoCategoryWhereInput, skip: Int = 0, limit: Int = 5, text: String!): [VideoCategoriesByNameFTSOutput!]!
  videoCategories(offset: Int, limit: Int = 50, where: VideoCategoryWhereInput, orderBy: VideoCategoryOrderByInput): [VideoCategory!]!
  videoCategoryByUniqueInput(where: VideoCategoryWhereUniqueInput!): VideoCategory
  videoCategoriesConnection(first: Int, after: String, last: Int, before: String, where: VideoCategoryWhereInput, orderBy: VideoCategoryOrderByInput): VideoCategoryConnection!
  videoMediaEncodings(offset: Int, limit: Int = 50, where: VideoMediaEncodingWhereInput, orderBy: VideoMediaEncodingOrderByInput): [VideoMediaEncoding!]!
  videoMediaEncodingByUniqueInput(where: VideoMediaEncodingWhereUniqueInput!): VideoMediaEncoding
  videoMediaEncodingsConnection(first: Int, after: String, last: Int, before: String, where: VideoMediaEncodingWhereInput, orderBy: VideoMediaEncodingOrderByInput): VideoMediaEncodingConnection!
  videoMediaMetadata(offset: Int, limit: Int = 50, where: VideoMediaMetadataWhereInput, orderBy: VideoMediaMetadataOrderByInput): [VideoMediaMetadata!]!
  videoMediaMetadataByUniqueInput(where: VideoMediaMetadataWhereUniqueInput!): VideoMediaMetadata
  videoMediaMetadataConnection(first: Int, after: String, last: Int, before: String, where: VideoMediaMetadataWhereInput, orderBy: VideoMediaMetadataOrderByInput): VideoMediaMetadataConnection!
  videos(offset: Int, limit: Int = 50, where: VideoWhereInput, orderBy: VideoOrderByInput): [Video!]!
  videoByUniqueInput(where: VideoWhereUniqueInput!): Video
  videosConnection(first: Int, after: String, last: Int, before: String, where: VideoWhereInput, orderBy: VideoOrderByInput): VideoConnection!
  workers(offset: Int, limit: Int = 50, where: WorkerWhereInput, orderBy: WorkerOrderByInput): [Worker!]!
  workerByUniqueInput(where: WorkerWhereUniqueInput!): Worker
  workersConnection(first: Int, after: String, last: Int, before: String, where: WorkerWhereInput, orderBy: WorkerOrderByInput): WorkerConnection!
}

type SearchFTSOutput {
  item: SearchSearchResult!
  rank: Float!
  isTypeOf: String!
  highlight: String!
}

union SearchSearchResult = Channel | Video

type StandardDeleteResponse {
  id: ID!
}

type Subscription {
  stateSubscription: ProcessorState!
}

type Video implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  channel: Channel
  channelId: String
  category: VideoCategory
  categoryId: String

  """The title of the video"""
  title: String

  """The description of the Video"""
  description: String

  """Video duration in seconds"""
  duration: Int
  thumbnailPhotoDataObject: DataObject
  thumbnailPhotoDataObjectId: String

  """URLs where the asset content can be accessed (if any)"""
  thumbnailPhotoUrls: [String!]!

  """Availability meta information"""
  thumbnailPhotoAvailability: AssetAvailability!
  language: Language
  languageId: String

  """Whether or not Video contains marketing"""
  hasMarketing: Boolean

  """
  If the Video was published on other platform before beeing published on Joystream - the original publication date
  """
  publishedBeforeJoystream: DateTime

  """Whether the Video is supposed to be publically displayed"""
  isPublic: Boolean

  """Flag signaling whether a video is censored."""
  isCensored: Boolean!

  """Whether the Video contains explicit material."""
  isExplicit: Boolean
  license: License
  licenseId: String
  mediaDataObject: DataObject
  mediaDataObjectId: String

  """URLs where the asset content can be accessed (if any)"""
  mediaUrls: [String!]!

  """Availability meta information"""
  mediaAvailability: AssetAvailability!
  mediaMetadata: VideoMediaMetadata
  mediaMetadataId: String
  createdInBlock: Int!

  """Is video featured or not"""
  isFeatured: Boolean!
}

type VideoCategoriesByNameFTSOutput {
  item: VideoCategoriesByNameSearchResult!
  rank: Float!
  isTypeOf: String!
  highlight: String!
}

union VideoCategoriesByNameSearchResult = VideoCategory

type VideoCategory implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """The name of the category"""
  name: String
  videos: [Video!]!
  createdInBlock: Int!
}

type VideoCategoryConnection {
  totalCount: Int!
  edges: [VideoCategoryEdge!]!
  pageInfo: PageInfo!
}

input VideoCategoryCreateInput {
  name: String
  createdInBlock: Float!
}

type VideoCategoryEdge {
  node: VideoCategory!
  cursor: String!
}

enum VideoCategoryOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  name_ASC
  name_DESC
  createdInBlock_ASC
  createdInBlock_DESC
}

input VideoCategoryUpdateInput {
  name: String
  createdInBlock: Float
}

input VideoCategoryWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  name_eq: String
  name_contains: String
  name_startsWith: String
  name_endsWith: String
  name_in: [String!]
  createdInBlock_eq: Int
  createdInBlock_gt: Int
  createdInBlock_gte: Int
  createdInBlock_lt: Int
  createdInBlock_lte: Int
  createdInBlock_in: [Int!]
}

input VideoCategoryWhereUniqueInput {
  id: ID!
}

type VideoConnection {
  totalCount: Int!
  edges: [VideoEdge!]!
  pageInfo: PageInfo!
}

input VideoCreateInput {
  channelId: ID
  categoryId: ID
  title: String
  description: String
  duration: Float
  thumbnailPhotoDataObjectId: ID
  thumbnailPhotoUrls: [String!]!
  thumbnailPhotoAvailability: AssetAvailability!
  languageId: ID
  hasMarketing: Boolean
  publishedBeforeJoystream: DateTime
  isPublic: Boolean
  isCensored: Boolean!
  isExplicit: Boolean
  licenseId: ID
  mediaDataObjectId: ID
  mediaUrls: [String!]!
  mediaAvailability: AssetAvailability!
  mediaMetadataId: ID
  createdInBlock: Float!
  isFeatured: Boolean!
}

type VideoEdge {
  node: Video!
  cursor: String!
}

type VideoMediaEncoding implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """Encoding of the video media object"""
  codecName: String

  """Media container format"""
  container: String

  """Content MIME type"""
  mimeMediaType: String
  videomediametadataencoding: [VideoMediaMetadata!]
}

type VideoMediaEncodingConnection {
  totalCount: Int!
  edges: [VideoMediaEncodingEdge!]!
  pageInfo: PageInfo!
}

input VideoMediaEncodingCreateInput {
  codecName: String
  container: String
  mimeMediaType: String
}

type VideoMediaEncodingEdge {
  node: VideoMediaEncoding!
  cursor: String!
}

enum VideoMediaEncodingOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  codecName_ASC
  codecName_DESC
  container_ASC
  container_DESC
  mimeMediaType_ASC
  mimeMediaType_DESC
}

input VideoMediaEncodingUpdateInput {
  codecName: String
  container: String
  mimeMediaType: String
}

input VideoMediaEncodingWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  codecName_eq: String
  codecName_contains: String
  codecName_startsWith: String
  codecName_endsWith: String
  codecName_in: [String!]
  container_eq: String
  container_contains: String
  container_startsWith: String
  container_endsWith: String
  container_in: [String!]
  mimeMediaType_eq: String
  mimeMediaType_contains: String
  mimeMediaType_startsWith: String
  mimeMediaType_endsWith: String
  mimeMediaType_in: [String!]
}

input VideoMediaEncodingWhereUniqueInput {
  id: ID!
}

type VideoMediaMetadata implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  encoding: VideoMediaEncoding
  encodingId: String

  """Video media width in pixels"""
  pixelWidth: Int

  """Video media height in pixels"""
  pixelHeight: Int

  """Video media size in bytes"""
  size: Float
  video: Video
  createdInBlock: Int!
}

type VideoMediaMetadataConnection {
  totalCount: Int!
  edges: [VideoMediaMetadataEdge!]!
  pageInfo: PageInfo!
}

input VideoMediaMetadataCreateInput {
  encodingId: ID
  pixelWidth: Float
  pixelHeight: Float
  size: Float
  createdInBlock: Float!
}

type VideoMediaMetadataEdge {
  node: VideoMediaMetadata!
  cursor: String!
}

enum VideoMediaMetadataOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  encodingId_ASC
  encodingId_DESC
  pixelWidth_ASC
  pixelWidth_DESC
  pixelHeight_ASC
  pixelHeight_DESC
  size_ASC
  size_DESC
  createdInBlock_ASC
  createdInBlock_DESC
}

input VideoMediaMetadataUpdateInput {
  encodingId: ID
  pixelWidth: Float
  pixelHeight: Float
  size: Float
  createdInBlock: Float
}

input VideoMediaMetadataWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  encodingId_eq: ID
  encodingId_in: [ID!]
  pixelWidth_eq: Int
  pixelWidth_gt: Int
  pixelWidth_gte: Int
  pixelWidth_lt: Int
  pixelWidth_lte: Int
  pixelWidth_in: [Int!]
  pixelHeight_eq: Int
  pixelHeight_gt: Int
  pixelHeight_gte: Int
  pixelHeight_lt: Int
  pixelHeight_lte: Int
  pixelHeight_in: [Int!]
  size_eq: Float
  size_gt: Float
  size_gte: Float
  size_lt: Float
  size_lte: Float
  size_in: [Float!]
  createdInBlock_eq: Int
  createdInBlock_gt: Int
  createdInBlock_gte: Int
  createdInBlock_lt: Int
  createdInBlock_lte: Int
  createdInBlock_in: [Int!]
}

input VideoMediaMetadataWhereUniqueInput {
  id: ID!
}

enum VideoOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  channelId_ASC
  channelId_DESC
  categoryId_ASC
  categoryId_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  duration_ASC
  duration_DESC
  thumbnailPhotoDataObjectId_ASC
  thumbnailPhotoDataObjectId_DESC
  thumbnailPhotoAvailability_ASC
  thumbnailPhotoAvailability_DESC
  languageId_ASC
  languageId_DESC
  hasMarketing_ASC
  hasMarketing_DESC
  publishedBeforeJoystream_ASC
  publishedBeforeJoystream_DESC
  isPublic_ASC
  isPublic_DESC
  isCensored_ASC
  isCensored_DESC
  isExplicit_ASC
  isExplicit_DESC
  licenseId_ASC
  licenseId_DESC
  mediaDataObjectId_ASC
  mediaDataObjectId_DESC
  mediaAvailability_ASC
  mediaAvailability_DESC
  mediaMetadataId_ASC
  mediaMetadataId_DESC
  createdInBlock_ASC
  createdInBlock_DESC
  isFeatured_ASC
  isFeatured_DESC
}

input VideoUpdateInput {
  channelId: ID
  categoryId: ID
  title: String
  description: String
  duration: Float
  thumbnailPhotoDataObjectId: ID
  thumbnailPhotoUrls: [String!]
  thumbnailPhotoAvailability: AssetAvailability
  languageId: ID
  hasMarketing: Boolean
  publishedBeforeJoystream: DateTime
  isPublic: Boolean
  isCensored: Boolean
  isExplicit: Boolean
  licenseId: ID
  mediaDataObjectId: ID
  mediaUrls: [String!]
  mediaAvailability: AssetAvailability
  mediaMetadataId: ID
  createdInBlock: Float
  isFeatured: Boolean
}

input VideoWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  channelId_eq: ID
  channelId_in: [ID!]
  categoryId_eq: ID
  categoryId_in: [ID!]
  title_eq: String
  title_contains: String
  title_startsWith: String
  title_endsWith: String
  title_in: [String!]
  description_eq: String
  description_contains: String
  description_startsWith: String
  description_endsWith: String
  description_in: [String!]
  duration_eq: Int
  duration_gt: Int
  duration_gte: Int
  duration_lt: Int
  duration_lte: Int
  duration_in: [Int!]
  thumbnailPhotoDataObjectId_eq: ID
  thumbnailPhotoDataObjectId_in: [ID!]
  thumbnailPhotoAvailability_eq: AssetAvailability
  thumbnailPhotoAvailability_in: [AssetAvailability!]
  languageId_eq: ID
  languageId_in: [ID!]
  hasMarketing_eq: Boolean
  hasMarketing_in: [Boolean!]
  publishedBeforeJoystream_eq: DateTime
  publishedBeforeJoystream_lt: DateTime
  publishedBeforeJoystream_lte: DateTime
  publishedBeforeJoystream_gt: DateTime
  publishedBeforeJoystream_gte: DateTime
  isPublic_eq: Boolean
  isPublic_in: [Boolean!]
  isCensored_eq: Boolean
  isCensored_in: [Boolean!]
  isExplicit_eq: Boolean
  isExplicit_in: [Boolean!]
  licenseId_eq: ID
  licenseId_in: [ID!]
  mediaDataObjectId_eq: ID
  mediaDataObjectId_in: [ID!]
  mediaAvailability_eq: AssetAvailability
  mediaAvailability_in: [AssetAvailability!]
  mediaMetadataId_eq: ID
  mediaMetadataId_in: [ID!]
  createdInBlock_eq: Int
  createdInBlock_gt: Int
  createdInBlock_gte: Int
  createdInBlock_lt: Int
  createdInBlock_lte: Int
  createdInBlock_in: [Int!]
  isFeatured_eq: Boolean
  isFeatured_in: [Boolean!]
}

input VideoWhereUniqueInput {
  id: ID!
}

type Worker implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """Sign of worker still being active"""
  isActive: Boolean!

  """Runtime identifier"""
  workerId: String!

  """Associated working group"""
  type: WorkerType!

  """Custom metadata set by provider"""
  metadata: String
  dataObjects: [DataObject!]!
}

type WorkerConnection {
  totalCount: Int!
  edges: [WorkerEdge!]!
  pageInfo: PageInfo!
}

input WorkerCreateInput {
  isActive: Boolean!
  workerId: String!
  type: WorkerType!
  metadata: String
}

type WorkerEdge {
  node: Worker!
  cursor: String!
}

enum WorkerOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  isActive_ASC
  isActive_DESC
  workerId_ASC
  workerId_DESC
  type_ASC
  type_DESC
  metadata_ASC
  metadata_DESC
}

enum WorkerType {
  GATEWAY
  STORAGE
}

input WorkerUpdateInput {
  isActive: Boolean
  workerId: String
  type: WorkerType
  metadata: String
}

input WorkerWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  isActive_eq: Boolean
  isActive_in: [Boolean!]
  workerId_eq: String
  workerId_contains: String
  workerId_startsWith: String
  workerId_endsWith: String
  workerId_in: [String!]
  type_eq: WorkerType
  type_in: [WorkerType!]
  metadata_eq: String
  metadata_contains: String
  metadata_startsWith: String
  metadata_endsWith: String
  metadata_in: [String!]
}

input WorkerWhereUniqueInput {
  id: ID!
}
