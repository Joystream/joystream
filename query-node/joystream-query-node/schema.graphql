"Stored information about a registered user"
type Member @entity {
	memberId: BigInt!

	"The unique handle chosen by member"
	handle: String @fulltext(query: "handles")

	"A Url to member's Avatar image"
	avatarUri: String

	"Short text chosen by member to share information about themselves"
	about: String

	"Blocknumber when member was registered"
	registeredAtBlock: BigInt!

	"Member's controller account id"
	controllerAccount: Bytes!

	"Member's root account id"
	rootAccount: Bytes!
}

"""
It represents a conceptual category, similar - but not identical,
to tables in relational databases and classes in object-oriented programming
Examples of classes in our example could be:
- Person: represents the concept of a person.
- Place: represents the concept of a place.
- PersonLivedInPlace: represents the concept that a person lived in a place.
"""
type Class @entity {
	"Runtime identifier for class"
	classId: BigInt!

	"Name of class"
	name: String!

	"Description of class"
	description: String!

	"The maximum number of entities which can be created"
	maximumEntitiesCount: BigInt!

	"The current number of entities which exist"
	currentNumberOfEntities: BigInt!

	"How many entities a given controller may create at most"
	defaultEntityCreationVoucherUpperBound: BigInt!

	"For this permission, the individual member is allowed to create the entity and become controller"
	anyMemberCanCreate: Boolean

	"Whether to prevent everyone from creating an entity"
	entityCreationBlocked: Boolean!

	"Whether to prevent everyone from updating entity properties"
	allEntityPropertyValuesLocked: Boolean!

	"All properties that have been used on this class across different class schemas"
	properties: [Property!]

	"All schemas that are available for this class, think v0.0 Person, v.1.0 Person, etc."
	schemas: [Schema!] @derivedFrom(field: "class")

	"Current class maintainer curator groups"
	maintainers: [CuratorGroup!]

	"All vouchers for this class"
	vouchers: [EntityCreationVoucher!] @derivedFrom(field: "class")
}

enum PropertyType {
	BOOL
	UINT16
	UINT32
	UINT64
	INT16
	INT32
	INT64
	TEXT
	REFERENCE
	VECBOOL
	VECUINT16
	VECUINT32
	VECUINT64
	VECINT16
	VECINT32
	VECINT64
	VECTEXT
	VECREFERENCE
}

"`Property` representation, related to a given `Class`"
type Property @entity {
	"Runtime identifier for property in class"
	propertyID: BigInt!

	"Type of `Property`"
	propertyType: PropertyType!

	"If property value can be skipped, when adding entity schema support"
	required: Boolean!

	"Used to enforce uniqeness of a property across all entities that have this property"
	unique: Boolean!

	"Name of property"
	name: String!

	"Description of property"
	description: String!

	# Property is locked from maintainer
	isLockedFromMaintainer: Boolean!

	# Property is locked from controller
	isLockedFromController: Boolean!

	"Upper bound for vector length when property is a vector"
	maximumLength: BigInt

	"Optional field, it must reference a class then PropertyType is Reference"
	referencedClass: Class

	"Optional field, Only will be set when PropertyType is Reference"
	sameControllerStatus: Boolean

	"Schemas which involve this property"
	schemas: [Schema!] @derivedFrom(field: "properties")
}

"Represents a standard for what information must be associated with any entity of a given class"
type Schema @entity {
	"Runtime identifier of schema in class"
	schemaId: BigInteger!

	"Class to which this schema corresponds"
	class: Class!

	"Properties of class that are in this schema"
	properties: [Property!]

	"If schema can be added to an entity"
	isActive: Boolean!
}

