"Stored information about a registered user"
type Member @entity {
  memberId: BigInt!

  "The unique handle chosen by member"
  handle: String @fulltext(query: "handles")

  "A Url to member's Avatar image"
  avatarUri: String

  "Short text chosen by member to share information about themselves"
  about: String

  "Blocknumber when member was registered"
  registeredAtBlock: BigInt!

  "Member's controller account id"
  controllerAccount: Bytes!

  "Member's root account id"
  rootAccount: Bytes!
}

"will be handled by governance/election.rs::CouncilElected"
type Council @entity {

  councilId: BigInt!

  members: [CouncilMember!]! @derivedFrom(field: 'council')

  startedAtBlock: BigInt!

  "When not set, then it has not ended yet, its in session"
  endedAtBlock: BigInt
}


type CouncilMember @entity {

  councilMemberId: BigInt!

  member: Member!

  stakeBalance: BigInt!

  council: Council!
}

enum VoteKind {
  APPROVE
  REJECT
  SLASH
  ABSTAIN
}

type VoteOnProposal @entity {

  voteId: BigInt!

  councilMember: CouncilMember!

  proposal: Proposal!

  voteKind: VoteKind!
}

"Proposal types"
enum ProposalType {
  Text
  RuntimeUpgrade
  Spending
  SetLead
  SetContentWorkingGroupMintCapacity
  SetValidatorCount
  AddWorkingGroupLeaderOpening
  BeginReviewWorkingGroupLeaderApplications
  FillWorkingGroupLeaderOpening
  SetWorkingGroupMintCapacity
  DecreaseWorkingGroupLeaderStake
  SlashWorkingGroupLeaderStake
  SetWorkingGroupLeaderReward
  TerminateWorkingGroupLeaderRole
}

enum ProposalState {
  ACTIVE
  CANCELLED
  VETOED
  REJECTED
  SLASHED
  EXPIRED
  GRACING
  EXECUTED
}

type Active @variant {
  votes: Int!
}

type Finalized @variant {
  finalizedAtBlock: BigInt

  "Amount which was staked"
  stakeBalance: BigInt!

  abstentionVotes: BigInt!

  approvalVotes: BigInt!

  rejectionVotes: BigInt!

  slashVotes: BigInt!
}

union ProposalStatus = Active | Finalized

interface Proposal @entity {

  "Id of a newly created proposal"
  proposalId: BigInt!

  type: ProposalType!

  "Identifier of member proposing"
  proposer: Member!

  "Proposal description"
  title: String @fulltext(query: 'title')

  "Proposal body"
  description: String @fulltext(query: 'description')

  "When it was created"
  createdAtBlock: BigInt!

  discussionThread: ProposalDiscussionThread! @derivedFrom(field: 'proposal')

  "Current status of the proposal"
  status: ProposalStatus!

  state: ProposalState!

}

"Will be handled by ThreadCreated, ..."
type ProposalDiscussionThread @entity {

  threadId: BigInt!

  title: String

  createdAtBlock: BigInt

  proposal: Proposal!

  posts: [ProposalDiscussionThreadPost!] @derivedFrom(field: 'thread')
}

"Will be handled by proposals/discussion::PostCreated"
type ProposalDiscussionThreadPost @entity {
  postId: BigInt!

  thread: ProposalDiscussionThread!

  # If not set, then it was the proposer who made post.
  # This is a safe representation, until we start other actors,
  # unfortunately the graphql typesystem is likely to weak to keep us safe at that time.
  councilMemberWhenAuthor: CouncilMember

  text: String!

  createdAtBlock: BigInt!

  "Counting creation as an update"
  lastUpdatedAtBlock: BigInt

  editionNumber: BigInt
}

"The text of the `text` proposal"
type TextProposal implements Proposal @entity {
  text: String!
}

"The wasm code for the `runtime upgrade` proposal"
type RuntimeUpgradeProposal implements Proposal @entity {
  wasm: Bytes!
}

"Election parameters for the `set election parameters` proposal"
type SetElectionParametersProposal implements Proposal @entity {
  announcingPeriod: BigInt!
  votingPeriod: BigInt!
  revealingPeriod: BigInt!
  councilSize: Int!
  candidacyLimit: Int!
  newTermDuration: BigInt!
  minCouncilStake: BigInt!
  minVotingStake: BigInt!
}

type SpendingProposal implements Proposal @entity {
  "Balance"
  mintedBalance: BigInt!

  "Destination account for the `spending` proposal"
  accountId: String!
}

"New leader memberId and account_id for the `set lead` proposal (Option<(MemberId, AccountId)>)"
type SetLeadProposal implements Proposal @entity {
  member: Member
}

"Balance for the `set content working group mint capacity` proposal"
type SetContentWorkingGroupMintCapacityProposal implements Proposal @entity {
  mintedBalance: BigInt!
}

"Validator count for the `set validator count` proposal"
type SetValidatorCountProposal implements Proposal @entity {
  validatorCount: Int!
}


enum WorkingGroup {
  STORAGE
}

"Begin review applications for the working group leader position"
type BeginReviewWorkingGroupLeaderApplicationsProposal implements Proposal @entity {
  openingId: BigInt!
  workingGroup: WorkingGroup
}

"Set working group mint capacity"
type SetWorkingGroupMintCapacityProposal implements Proposal @entity {
  mintedBalance: BigInt!
  workingGroup: WorkingGroup
}

type DecreaseWorkingGroupLeaderStakeProposal implements Proposal @entity {
  workerId: BigInt!
  workingGroup: WorkingGroup
}

" Slash the working group leader stake."
type SlashWorkingGroupLeaderStakeProposal implements Proposal @entity {
  workerId: BigInt!
  workingGroup: WorkingGroup
}

"Set working group leader reward balance."
type SetWorkingGroupLeaderRewardProposal implements Proposal @entity {
  workerId: BigInt!
  mintedBalance: BigInt!
  workingGroup: WorkingGroup
}

"Fire the working group leader with possible slashing"
# TerminateWorkingGroupLeaderRole(TerminateRoleParameters<WorkerId>),

"Fill opening for the working group leader position"
# FillWorkingGroupLeaderOpening(
#     FillOpeningParameters<BlockNumber, MintedBalance, OpeningId, ApplicationId>,
# )

"Add opening for the working group leader position"
# AddWorkingGroupLeaderOpening(AddOpeningParameters<BlockNumber, CurrencyBalance>)






