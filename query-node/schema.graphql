enum Network {
  BABYLON
  ALEXANDRIA
  ROME
}

type Block @entity {
  "Block number as a string"
  id: ID!
  block: Int!
  timestamp: BigInt!
  network: Network!
}

enum MembershipEntryMethod {
  PAID
  SCREENING
  GENESIS
}

"Stored information about a registered user"
type Membership @entity {
  "MemberId: runtime identifier for a user"
  id: ID!

  "The unique handle chosen by member"
  handle: String! @unique @fulltext(query: "membersByHandle")

  "A Url to member's Avatar image"
  avatarUri: String!

  "Short text chosen by member to share information about themselves"
  about: String!

  "Member's controller account id"
  controllerAccount: String!

  "Member's root account id"
  rootAccount: String!

  "Blocknumber when member was registered"
  registeredAtBlock: Block!

  "Timestamp when member was registered"
  registeredAtTime: BigInt!

  "How the member was registered"
  entry: MembershipEntryMethod!

  "The type of subscription the member has purchased if any."
  subscription: BigInt
}

# TODO: add description to fields
# TODO: revise property requirement for the new and existing fields derived from content-metadata-protobuf

type Account @entity {
  id: ID!
}

type ChannelCategory @entity {
  id: ID!

  name: String
}

type Person @entity {
  id: ID!

  firstName: String

  middleName: String

  lastName: String

  about: String

  coverPhotoUrl: String

  avatarPhotoUrl: String

  videos: [Video] @derivedFrom(field: "people")

  seasons: [Season] @derivedFrom(field: "people")

  series: [Series] @derivedFrom(field: "people")
}

type Playlist @entity {
  id: ID!

  title: String

  videos: [Video]
}

type Season @entity {
  id: ID!

  title: String

  description: String

  coverPhoto: String

  people: [Person]

  episodes: [Video]

  series: Series @derivedFrom(field: "seasons")
}

type Series @entity {
  id: ID!

  in_channel: Channel!

  title: String

  description: String

  coverPhoto: String

  people: [Person]

  seasons: [Season]
}

type Asset @entity {
  id: ID!

  url: String!
}


"""
This type is to keep which entity belongs to which class. This type will be used
by EntityCreated event. When a new schema support added to an Entity we will get the
class name from this table.
We need this because we can't create a database row (Channel, Video etc) without
with empty fields.
"""
type ClassEntity @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  "The class id of this entity"
  classId: Int!

  happenedIn: Block!
}

"Keep track of the next entity id"
type NextEntityId @entity {
  "Constant field is set to '1'"
  id: ID!

  nextId: Int!
}

#### High Level Derivative Entities ####

type Language @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  name: String!
  code: String!

  happenedIn: Block!
}

type Channel @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  # "Owner of the channel" Commenting out this field: 'owner' can be curator_group, lead
  # or a member. We are not handling events related to curator group so we will not set this field
  # owner: Member!

  category: ChannelCategory

  "The title of the Channel"
  handle: String! @fulltext(query: "search")

  "The description of a Channel"
  description: String!

  "Url for Channel's cover (background) photo. Recommended ratio: 16:9."
  coverPhotoUrl: String

  "Channel's avatar photo."
  avatarPhotoUrl: String

  "Flag signaling whether a channel is public."
  isPublic: Boolean!

  "The primary langauge of the channel's content"
  language: Language

  videos: [Video!] @derivedFrom(field: "channel")

  happenedIn: Block!
}

type Category @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  "The name of the category"
  name: String! @unique @fulltext(query: "categoriesByName")

  "The description of the category"
  description: String

  videos: [Video!] @derivedFrom(field: "category")

  happenedIn: Block!
}

"Encoding and containers"
type VideoMediaEncoding @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  name: String!

  happenedIn: Block!
}

type KnownLicenseEntity @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  "Short, commonly recognized code of the licence (ie. CC_BY_SA)"
  code: String! @unique

  "Full, descriptive name of the license (ie. Creative Commons - Attribution-NonCommercial-NoDerivs)"
  name: String

  "Short description of the license conditions"
  description: String

  "An url pointing to full license content"
  url: String

  happenedIn: Block!
}

type UserDefinedLicenseEntity @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  "Custom license content"
  content: String!

  happenedIn: Block!
}

type MediaLocationEntity @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  # One of the following field will be non-null

  "A reference to HttpMediaLocation"
  httpMediaLocation: HttpMediaLocationEntity

  "A reference to JoystreamMediaLocation"
  joystreamMediaLocation: JoystreamMediaLocationEntity

  videoMedia: VideoMedia @derivedFrom(field: "locationEntity")

  happenedIn: Block!
}

type JoystreamMediaLocationEntity @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  "Id of the data object in the Joystream runtime dataDirectory module"
  dataObjectId: String! @unique

  happenedIn: Block!
}

type HttpMediaLocationEntity @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  "The http url pointing to the media"
  url: String!

  "The port to use when connecting to the http url (defaults to 80)"
  port: Int

  happenedIn: Block!
}

type MediaType @entity {
  id: ID!

  codecName: String

  container: String

  mimeMediaType: String
}

type PublishedBeforeJoystream @entity {
  id: ID!

  isPublished: String

  timestamp: BigInt
}

type VideoMedia @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  "Encoding of the video media object"
  encoding: VideoMediaEncoding!

  "Video media width in pixels"
  pixelWidth: Int!

  "Video media height in pixels"
  pixelHeight: Int!

  "Video media size in bytes"
  size: Int

  video: Video @derivedFrom(field: "media")

  "Location of the video media object"
  location: MediaLocation!

  locationEntity: MediaLocationEntity

  publishedBeforeJoystream: PublishedBeforeJoystream

  happenedIn: Block!
}

type Video @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  "Reference to member's channel"
  channel: Channel!

  "Reference to a video category"
  category: Category!

  "The title of the video"
  title: String! @fulltext(query: "search")

  "The description of the Video"
  description: String!

  "Video duration in seconds"
  duration: Int!

  "Video's skippable intro duration in seconds"
  skippableIntroDuration: Int

  "Video thumbnail url (recommended ratio: 16:9)"
  thumbnailUrl: String!

  "Video's main langauge"
  language: Language

  "Reference to VideoMedia"
  media: VideoMedia!

  "Whether or not Video contains marketing"
  hasMarketing: Boolean

  "If the Video was published on other platform before beeing published on Joystream - the original publication date"
  publishedBeforeJoystream: Int

  "Whether the Video is supposed to be publically displayed"
  isPublic: Boolean!

  "Whether the Video contains explicit material."
  isExplicit: Boolean!

  license: LicenseEntity!

  happenedIn: Block!

  "Is video featured or not"
  isFeatured: Boolean!

  people: [Person]

  featured: FeaturedVideo @derivedFrom(field: "video")

  playlists: Playlist @derivedFrom(field: "videos")

  seasons: Season @derivedFrom(field: "episodes")
}

type JoystreamMediaLocation @variant {
  "Id of the data object in the Joystream runtime dataDirectory module"
  dataObjectId: String!
}

type HttpMediaLocation @variant {
  "The http url pointing to the media"
  url: String!

  "The port to use when connecting to the http url (defaults to 80)"
  port: Int
}

union MediaLocation = HttpMediaLocation | JoystreamMediaLocation

type KnownLicense @variant {
  "Short, commonly recognized code of the licence (ie. CC_BY_SA)"
  code: String!

  "Full, descriptive name of the license (ie. Creative Commons - Attribution-NonCommercial-NoDerivs)"
  name: String

  "Short description of the license conditions"
  description: String

  "An url pointing to full license content"
  url: String
}

type UserDefinedLicense @variant {
  "Custom license content"
  content: String!
}

union License = KnownLicense | UserDefinedLicense

type LicenseEntity @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  type: License!

  "Attribution (if required by the license)"
  attribution: String

  happenedIn: Block!
}

type FeaturedVideo @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  "Reference to a video"
  video: Video!
}
