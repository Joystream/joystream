### 0.20.0

- `@polkadot/api` upgraded from `5.9.1` to `8.9.1` (along with related dependencies)
- All custom classes for Joystream runtime types have been removed! Since the `@polkadot/api` no longer relies on custom type definitions provided during `ApiPromise` instantiation for chains using metadata v14, there is no point in maintaining custom type classes. The interfaces for all custom types are still automatically generated from the chain metadata.
- `@polkadot/typegen`-related scripts were modified in order to generate everything just from the chain metadata
- Scripts related to custom type classes (ie. generating `augment-codec`) were removed, as custom type classes no longer exist
- All augmentations are now part of `./src` and imported in `@joystream/types` by default, which means that any import from `@joystream/types` now also automatically imports the api/type augmentations
- `createType` function was modified to work with interfaces generated via `@polkadot/typegen`
- `keysOf` utility function was added (see the migration guide below)
- `entriesByIds` utility function was added
- `AsCodec` utility type was added (see the migration guide below)
- `JOYSTREAM_ADDRESS_PREFIX` constant was added
- New `primitives.ts` file was added, exporting aliases for primitive runtime types like `ProposalId` or `MemberId`

#### Migration guide

1. From `tsconfig.json` you can now remove theÂ `"@polkadot/types/augment"` and `"@polkadot/api/augment"` paths.
   Augmentations are now directly imported in `@joystream/types`, so in order to use them just make sure to:

   ```typescript
   import '@joystream/types'
   ```

   somewhere in your project

1. When you instantiate `ApiPromise`, you no longer need to provide `types`:

   **Before:**

   ```typescript
   import { types } from '@joystream/types'

   // ...
   const api = await ApiPromise.create({ provider, types })
   ```

   **Now:**

   ```typescript
   const api = await ApiPromise.create({ provider })
   ```

1. All custom type interfaces should now be imported from the augmented `'@polkadot/types/lookup'`. Notice that the type names now include the pallet name as a prefix. They may also include an additional suffix like `Object`/`Record`, because the type names are no longer based on runtime alises. For example:

   **Before:**

   ```typescript
   import { Membership } from '@joystream/types/members'
   ```

   **Now:**

   ```typescript
   import { PalletMembershipMembershipObject } from '@polkadot/types/lookup'
   ```

1. Because no runtime aliases are exposed in the v14 metadata, typescript aliases like `MemberId`, `ForumThreadId`, `ProposalId` etc. have been exposed in a new file called `primitives.ts`:

   **Before:**

   ```typescript
   import { ProposalId } from '@joystream/types/proposals'
   import { MemberId } from '@joystream/types/members'
   ```

   Now:

   ```typescript
   import { MemberId, ProposalId } from '@joystream/types/primitives'
   ```

1. Because custom type classes were following `snake_case` naming strategy for the `Struct` properties, but the interfaces generated by `@polkadot/typegen` are following `camelCase`, you should make the adjustments to your codebase accordingly, for example:

   **Before:**

   ```typescript
   // ...
   const councilStage = await api.query.council.stage()
   const changedAt = councilStage.changed_at
   ```

   **Now:**

   ```typescript
   // ...
   const councilStage = await api.query.council.stage()
   const { changedAt } = councilStage
   ```

1. Another difference between the old custom type classes and interfaces generated by `@polkadot/typegen` is that `isOfType` and `asType` methods (made available because of `JoyEnum`) will no longer exists for enums. You should use the decorated `isX`, `asX` getters instead.

   **Before:**

   ```typescript
   const groupId = channel.owner.isOfType('CuratorGroup') ? channel.owner.asType('CuratorGroup') : null
   ```

   **Now:**

   ```typescript
   const groupId = channel.owner.isCuratorGroup ? channel.owner.asCuratorGroup : null
   ```

1. Similarly to the enums, if you were relying on some custom `JoyStruct` methods like `getField()`, you should now resolve to using the decorated getters instead (note that `_` suffix is now added in case of property name clashes):

   **Before:**

   ```typescript
   const dataObject = await api.query.storage.dataObjectsById(/* ... */)
   const dataObjectContentId = dataObject.ipfs_content_id
   const dataObjectSize = dataObject.getField('size')
   ```

   **Now:**

   ```typescript
   const dataObject = await api.query.storage.dataObjectsById(/* ... */)
   const dataObjectContentId = dataObject.ipfsContentId
   const dataObjectSize = dataObject.size_
   ```

1. Constants that represent the custom `Enum`/`Struct` definitions like `WorkingGroupDef` no longer exist. They were sometimes used, for example, in order to iterate over all existing enum variants. For this specific purpose, the `keysOf` utility function was added to `'@joystream/types'`:

   **Before:**

   ```typescript
   import { WorkingGroupDef, WorkingGroupKey } from '@joystream/types/common'

   // ...
   ;(Object.keys(WorkingGroupDef) as WorkingGroupKey).forEach((group) => {
     /* ... */
   })
   ```

   **Now:**

   ```typescript
   import { keysOf } from '@joystream/types'
   import { PalletCommonWorkingGroup } from '@polkadot/types/lookup'

   // ...
   keysOf<PalletCommonWorkingGroup, 'PalletCommonWorkingGroup'>('PalletCommonWorkingGroup').forEach(group, () => /* ... */)
   ```

1. If you were using custom classes to create a specific type instance, you should now use `createType` approach instead, for example:

   **Before:**

   ```typescript
   import { registry } from '@joystream/types'
   import { BuyMembershipParameters } from '@joystream/types/members'

   // ...
   new BuyMembershipParameters(registry, parameters)
   ```

   **Now:**

   ```typescript
   import { createType } from '@joystream/types'
   import { PalletMembershipBuyMembershipParameters } from '@polkadot/types/lookup'

   // ...
   createType('PalletMembershipBuyMembershipParameters', parameters)
   ```

   `createType` function will be fully typesafe, even for types with deep nesting.

1. Because the `api-query` augmentations generated by `@polkadot/typegen` now use `AsCodec<T>`, for example, for the `.entires` decoration, some old implementations of functions like `entiresByIds` may not be compatible with the new typings. In order to fix this, `AsCodec` was also added to `@joystream/types` and can be used to address similar issues. For example:

   **Before:**

   ```typescript
   async function entriesByIds<IDType extends UInt, ValueType extends Codec>(
     apiMethod: AugmentedQuery<'promise', (key: IDType) => Observable<ValueType>, [IDType]>
   ): Promise<[IDType, ValueType][]> {
     const entries: [IDType, ValueType][] = (await apiMethod.entries()).map(([storageKey, value]) => [
       storageKey.args[0] as IDType,
       value,
     ])

     return entries.sort((a, b) => a[0].toNumber() - b[0].toNumber())
   }
   ```

   **Now:**

   ```typescript
   import { AsCodec } from '@joystream/types'

   // ...

   async function entriesByIds<IDType extends UInt, ValueType extends Codec>(
     apiMethod: AugmentedQuery<'promise', (key: IDType) => Observable<ValueType>, [IDType]>
   ): Promise<[IDType, AsCodec<ValueType>][]> {
     const entries: [IDType, AsCodec<ValueType>][] = (await apiMethod.entries()).map(([storageKey, value]) => [
       storageKey.args[0] as IDType,
       value,
     ])

     return entries.sort((a, b) => a[0].toNumber() - b[0].toNumber())
   }
   ```

   Because `entriesByIds` as implemented above is quite frequently used, it is also now exported as a utility function from `@joystream/types`
